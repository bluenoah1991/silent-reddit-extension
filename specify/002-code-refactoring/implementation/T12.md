# 实现记录 - T12

## 任务信息
- **编号**: T12
- **描述**: 创建 mutation-observer.js 模块：实现 MutationObserver 封装和新增节点处理逻辑

## 实现细节

### 模块设计
创建了 `SilentReddit.mutationObserver` 对象，封装 MutationObserver 相关逻辑。

### 核心属性
```javascript
settingsManager: null,  // Settings manager 引用
observer: null          // MutationObserver 实例
```

### 核心方法

#### 1. init(settingsManager)
初始化 observer：
```javascript
init(settingsManager) {
    this.settingsManager = settingsManager;
}
```

**特点：**
- 依赖注入方式接收 SettingsManager
- 延迟创建 observer 实例（在 start() 时创建）

#### 2. _handleMutations(mutations) 私有方法
处理 DOM 变化：
```javascript
_handleMutations(mutations) {
    const settings = this.settingsManager.get();
    if (!settings.enabled) return;

    mutations.forEach(mutation => {
        if (mutation.type !== 'childList') return;

        mutation.addedNodes.forEach(node => {
            if (node.nodeType !== Node.ELEMENT_NODE || !node.matches) return;

            // Quick check for ads to hide immediately
            if (settings.blockAds) {
                SilentReddit.adsBlocker.hideNode(node);
            }

            // Apply all blocking rules to the new node
            SilentReddit.coordinator.applyToNode(node);
        });
    });

    // Check logo state (might have been changed by page navigation)
    if (settings.replaceLogo) {
        SilentReddit.logoReplacer.replaceAll();
    } else {
        SilentReddit.logoReplacer.restoreAll();
    }
}
```

**处理流程：**
1. 检查扩展是否启用，未启用则直接返回
2. 遍历所有 mutation，只处理 childList 类型
3. 遍历所有新增节点（addedNodes）
4. 过滤出元素节点（排除文本节点等）
5. 快速检查是否为广告并立即隐藏（性能优化）
6. 调用 coordinator.applyToNode 应用所有屏蔽规则
7. 检查并更新 Logo 状态（应对 SPA 路由切换）

**特点：**
- 使用 `adsBlocker.hideNode()` 快速隐藏广告
- 委托 coordinator 处理完整的屏蔽逻辑
- 每次 mutation 后检查 Logo（防止页面导航恢复原 Logo）

#### 3. start()
启动 observer：
```javascript
start() {
    if (this.observer) {
        console.log('[SR] Observer already running');
        return;
    }

    this.observer = new MutationObserver(this._handleMutations.bind(this));
    this.observer.observe(document.body, {
        childList: true,
        subtree: true
    });

    console.log('[SR] Mutation observer started');
}
```

**特点：**
- 防止重复启动（检查 this.observer）
- 使用 bind(this) 确保回调中 this 指向正确
- 监听 document.body 的 childList 和 subtree 变化
- 记录启动日志

#### 4. stop()
停止 observer：
```javascript
stop() {
    if (this.observer) {
        this.observer.disconnect();
        this.observer = null;
        console.log('[SR] Mutation observer stopped');
    }
}
```

**特点：**
- 断开连接并清空引用
- 记录停止日志

### Observer 配置
```javascript
{
    childList: true,  // 监听子节点添加/删除
    subtree: true     // 递归监听所有后代节点
}
```

**说明：**
- 不监听 attributes 和 characterData（不需要）
- 只关注新增节点（Reddit 瀑布流加载）

### 性能考虑
1. **快速广告检查**：在调用 coordinator 前先快速隐藏广告
2. **早期返回**：disabled 状态直接返回，避免不必要的处理
3. **节点过滤**：只处理 ELEMENT_NODE 类型
4. **委托处理**：将复杂逻辑委托给 coordinator

### 错误处理
- 采用 D05 错误处理策略：不使用 try-catch（依赖浏览器全局错误处理）
- 保持代码简洁，信任浏览器环境

### 设计原则
- ✅ **职责单一**：只负责监听 DOM 和分发节点处理
- ✅ **委托模式**：将屏蔽逻辑委托给 coordinator
- ✅ **依赖注入**：通过 init 接收依赖
- ✅ **生命周期管理**：提供 start/stop 方法

### 与旧代码对比
**旧代码 (handleMutations)：**
- 直接调用多个模块函数
- 包含重复的屏蔽逻辑

**新代码：**
- 委托 coordinator 统一协调
- 只保留快速广告检查（性能优化）
- 更清晰的职责划分

### 日志
- 模块加载：`[SR] Mutation observer module loaded`
- Observer 启动：`[SR] Mutation observer started`
- Observer 停止：`[SR] Mutation observer stopped`
- 重复启动警告：`[SR] Observer already running`

---
*创建时间: 2025-10-18*
